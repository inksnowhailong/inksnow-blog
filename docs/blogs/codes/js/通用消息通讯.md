---
title: 通用消息通讯
date: 2025-02-26
categories:
  - 编程
tags:
  - JS/TS
---

在我的编程小圈子里，出现了这样的一个话题：
:::  info 情况
    一个项目，要构建成多个部分，还要与APP进行混合，那么：
    - 多个部分是采用微前端库进行沟通还是先用iframe？
    - 与APP的通讯又使用什么库？
:::
这其中，考虑不同库和框架的特性，以及可移植性，其实还是有一些争论的，因为可能出现扩展的问题，以及若是未来某个库需要换成另一个库，修改的成本大小问题。

但是圈子里的人，都是分别讨论这两个问题的，各有各自的推荐方式。

个人的想法是：这根本就是一个**可以通过架构设计给忽略掉的同一个问题**

## 为什么？
无论是：
- APP与web端：比如DSBridge、UniWebView
- 多web端互通：比如乾坤、无界、iframe
- electron那种node端和web端
全都是类似于**发消息与监听消息**的东西，很类似于**发布-订阅模式（Publish-Subscribe Pattern，简称 Pub/Sub）**

相关的框架底层，也是依赖这种类型的内置方式进行实现的，但是通常会扩展一些已经定义好的API和规范
## 统一起来
那么，我们就可以基于此，抽象出来这个模式
将其抽象出来，让其数据的格式一样，让其发送和接收消息的方式也一样，其他的，怎么实现这些，都是可以随时更改的实现细节而已

*这里将展示web端的抽象，有了这个，换到APP端，也能通过各自在线免费的AI工具，转换成对应语言的抽象*
### 抽象接口
:::: code-group
::: code-group-item Bridge.ts
```typescript
// /Bridge.ts

/**
 * @description: 信息交流模块
 * @return {*}
 */
export interface Bridge {
  listenerBox: Record<string, BridgeListener>;
  sendMessage(message: MessageDto): void;
  addBridgeListener(listener: BridgeListener): void;
}

/**
 * @description: 监听消息的实例
 * @return {*}
 */
export interface BridgeListener<T = string> {
  listentType: T;
  onMessage(message: MessageDto): void;
}

/**
 * @description: 消息的数据类型,传递时转为json字符串，接收后反序列化
 * @return {*}
 */
export interface MessageDto<T = string> {
  /**
   * @description: 消息类型,用于区分不同的消息
   */
  messageType: T;
  /**
   * @description: 消息数据
   */
  data: Record<string, any>;
}

```
:::
::: code-group-item Bridge.enum.ts
```typescript
// /Bridge.enum.ts
enum TypeEnum {
    /**
   * @description: TOKEN传递 APP->Web
   */
    TOKEN = 'token'
}
```
:::
::::
#### 示例的实现

```typescript
/**
 * @description: wenview 通信模块
 * @return {*}
 */
export class webviewEvent implements Bridge {
  listenerBox: Record<string, BridgeListener> = {};
  constructor() {}
  sendMessage(message: MessageDto<TypeEnum>): void {
    // do something
    window.postMessage(JSON.stringify(message), "*");
  }
  addBridgeListener(listener: BridgeListener<TypeEnum>): void {
    this.listenerBox[listener.listentType] = listener;
  }
  openListening() {
    window.addEventListener("message", (event) => {
      const message = JSON.parse(event.data);
      const listener = this.listenerBox[message.messageType];
      if (listener) {
        listener.onMessage(message);
      }
    });
  }
}

/**
 * @description: 创建监听器   这个其实要不要都可以，有了，只是更方便创建一个监听器
 * @return {*}
 */
export class ListenerBuilder implements BridgeListener<TypeEnum> {
  listentType: TypeEnum;
  constructor(
    listentType: TypeEnum,
    onMessage: BridgeListener<TypeEnum>["onMessage"]
  ) {
    this.listentType = listentType;
    this.onMessage = onMessage;
  }
  onMessage(message: MessageDto<TypeEnum>): void {
    // do something
  }
}

```
### UML图，来展示一下依赖关系
@startuml

enum TypeEnum {
    TOKEN
}
interface MessageDto<T = string> {
  messageType: T;
  data: Record<string, any>;
}
interface BridgeListener<T = string> {
  listentType: T;
  onMessage(message: MessageDto): void;
}
interface Bridge{
    listenerBox:Map
    sendMessage(message: MessageDto):void
    addBridgeListener(listener: BridgeListener): void
}

MessageDto ..> TypeEnum  : MessageDto 的泛型 T 依赖 TypeEnum
BridgeListener --> MessageDto  : BridgeListener 的方法参数用 MessageDto
BridgeListener ..> TypeEnum  : BridgeListener 的泛型 T 依赖 TypeEnum
Bridge --> MessageDto  : Bridge 的方法参数用 MessageDto
Bridge --> BridgeListener  : Bridge 的方法参数用 BridgeListener
@enduml

## 如此进行设计之后
如此之后，无论是怎样的web跨端交互，我们都在开发时，不必再关系其到底是另一端是什么，或者是怎么实现的，我们只需要按照接口类型，进行调用和使用即可。

而且即使是切换了不同实现的库，也可以只在实现bridge的位置去修改其实现，即可全局进行实现的更改，重构成本极低。

 在实现上，也可以采用工厂模式，来一次次扩展不同实现。例如开头问题中,两个问题其实是一个问题，通过工厂模式，构建两个不同的Bridge，就可以完成这些东西。

::: warning 一些建议
    实现代码也可以结合单例模式和依赖注入，来让web中用起来及其方便，
:::
