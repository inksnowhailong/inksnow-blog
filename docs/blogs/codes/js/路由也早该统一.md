---
title: å‰ç«¯æŠ½è±¡åŒ–ï¼Œæ‰“ç ´æ¡†æ¶æ·é”:ç»Ÿä¸€è·¯ç”±çš„è®¾è®¡
date: 2025-3-17
categories:
 - ç¼–ç¨‹
 - æŠ½è±¡å‰ç«¯ï¼Œæ¶æ„è®¾è®¡
tags:
 - å®éªŒ
---
<style>
    .language-uml.line-numbers-mode{
        max-height:400px;
        overflow:auto;
    }
    .line-numbers-mode .line-numbers{
        bottom:auto;
        top:0;
    }
</style>
åªè¦ä½ æ˜¯åœ¨å†™å‰ç«¯é¡µé¢ï¼Œé‚£ä¹ˆå¥½çš„è·¯ç”±å¯¼èˆªæ— éå°±ä¸¤ç§
- ç¼–ç¨‹å¼å¯¼èˆª
- çº¦å®šå¼å¯¼èˆª

ä¸€ç§æ˜¯ä½ æ¥æ§åˆ¶å¯¼èˆªæ–¹å‘å’Œæ‰€æœ‰é¡µé¢çš„å¯¼èˆªè·¯å¾„ï¼Œå¦ä¸€ç§æ˜¯æ ¹æ®ç›®å½•ç»“æ„æ¥è‡ªåŠ¨ç”Ÿæˆå¯¼èˆª.
è€Œç¼–ç¨‹å¼å¯¼èˆªï¼Œä¹Ÿè®¸æˆ‘ä»¬ä¹Ÿåº”è¯¥æŠ½è±¡å‡ºæ¥ï¼Œç»Ÿä¸€ä¸‹ï¼Œè®©æˆ‘ä»¬åˆ‡æ¢vueã€reactäº¦æˆ–è€…å…¶ä»–ä¸œè¥¿éƒ½ä¸å¿…å†éœ€è¦å¤šä½™æˆæœ¬ã€‚
**æ‰€ä»¥ï¼Œä¾¿æœ‰äº†è¿™ä¸ªè®¾è®¡**
æˆ‘åœ¨è®¾è®¡è¿™ä¸ªæ¶æ„æ—¶ï¼Œæœ€æ ¸å¿ƒçš„ç†å¿µæ˜¯**æŠ½è±¡**ä¸**è§£è€¦**ã€‚æˆ‘å¸Œæœ›è·¯ç”±å¯¼èˆªçš„é€»è¾‘èƒ½å¤Ÿç‹¬ç«‹äºå…·ä½“çš„æ¡†æ¶å­˜åœ¨ï¼Œè¿™æ ·ä¸€å¥—ä»£ç å°±èƒ½é€‚é…å„ç§ç¯å¢ƒï¼Œæ—¢å‡å°‘é‡å¤å¼€å‘ï¼Œåˆæ–¹ä¾¿æœªæ¥çš„æ‰©å±•
## é¦–å…ˆè®¾è®¡çš„TSæºç æˆ‘å…ˆæ”¾åœ¨è¿™å„¿

[å¦‚æœä½ ä¸æƒ³å…ˆçœ‹è¿™äº›æºç ï¼Œè€Œæ˜¯æƒ³äº†è§£å…¶è®¾è®¡ç†ç”±å’Œæ€æƒ³ï¼Œé‚£ä¹ˆå®ƒåœ¨ä¸‹é¢ğŸ‘‡](#è¿™é‡Œé¢éƒ½æœ‰ä»€ä¹ˆ)

:::: code-group
::: code-group-item domain
```ts
/**
 * @description: è·¯ç”±æºå¸¦æ•°æ®
 * @return {*}
 */
export interface NavigationOptions {
  params?: Record<string, string>;
  query?: Record<string, string>;
  hash?: string;
}
/**
 * @description: è·³è½¬ç±»å‹
 * @return {*}
 */
export enum NavigationType {
    push = 'push',
    replace = 'replace',
    back = 'back',
    forward = 'forward',
}

/**
 * @description: è·¯ç”±å®ˆå«ï¼Œè¿”å›ä¸€ä¸ªçœŸæ­£è¦è·³è½¬çš„è·¯ç”±
 * @return {*} è¿”å›ä¸€ä¸ªæ–°çš„è·³è½¬è·¯å¾„ï¼Œæˆ–è€…ä»€ä¹ˆä¹Ÿä¸è¿”å›ï¼ŒæŒ‰åŸè®¡åˆ’è·³è½¬
 */
export interface RouteGuard {
    (context: NavigationContext): NavigationInstruction|void | Promise<NavigationInstruction|void>;
}

/**
 * @description: è·¯ç”±è¿›å…¥å‰çš„é’©å­
 * @return {*}
 */
export interface RouterBefore {
    (context: NavigationContext): void | Promise<void>;
}

/**
 * @description: è·¯ç”±ç¦»å¼€å‰çš„é’©å­
 * @return {*}
 */
export interface RouterLeave {
    (context: NavigationContext): void | Promise<void>;
}


/**
 * @description: è·¯ç”±ä¸Šä¸‹æ–‡
 * @return {*}
 */
export class NavigationContext {
  constructor(
    public instruction: NavigationInstruction,
    public prevInstruction: NavigationInstruction|null,
    public nextInstruction: NavigationInstruction|null,
    public currentRoute: ResolvedRoute,
  ) {}
}

/**
 * @description: è·¯ç”±æŒ‡ä»¤
 * @return {*}
 */
export class NavigationInstruction {
  constructor(
    public type: NavigationType,
    public target: string,
    public options: NavigationOptions,
    public timestamp: number
  ) {}
}

/**
 * @description: è·¯ç”±è§£æ
 * @return {*}
 */
export class ResolvedRoute {
  constructor(
    public path: string,
    public component: any,
    public guards: RouteGuard[] = [],
    public enterHook: RouterBefore[] = [],
    public leaveHook: RouterLeave[] = [],
    public children: ResolvedRoute[] = [],
    public metadata: Map<string, any> = new Map()
  ) {}
}

```
:::
::: code-group-item core
```ts
import {
  NavigationContext,
  NavigationInstruction,
  NavigationOptions,
  NavigationType,
  ResolvedRoute,
} from "./router_domain";

/**
 * @description:å¯¼èˆªå™¨ï¼Œä½¿ç”¨æœ‰ä¸¤ç§æ–¹å¼è¿›è¡Œç¼–ç¨‹å¼è·¯ç”±å¯¼èˆª
 * @return {*}
 */
export interface INavigator {
  to(
    type: NavigationType,
    target: string,
    options: NavigationOptions
  ): Promise<void>;
  push(target: string, options: NavigationOptions): Promise<void>;
  replace(target: string, options: NavigationOptions): Promise<void>;
  back(): Promise<void>;
  forward(): Promise<void>;
}

/**
 * @description: è·¯ç”±è§£æå™¨ï¼Œç”¨äºè§£æè·¯ç”±å®é™…å¯¹è±¡
 * @return {*}
 */
export interface IRouteResolver {
  resolve(path: string): Promise<ResolvedRoute>;
}

/**
 * @description: ä¸­é—´ä»¶é€»è¾‘ï¼Œç”¨äºå¤„ç†è·¯ç”±è·³è½¬å‰çš„éšæ—¶å¯æ’æ‹”å¤„ç†
 * @return {*}
 */
export interface IMiddleware {
  process(context: NavigationContext, next: () => Promise<void>): Promise<void>;
}

/**
 * @design: å»ºè®®å®ç°ä¸ºå•ä¾‹æ¨¡å¼
 * @description: å†å²ç®¡ç†å™¨ï¼Œç”¨äºç®¡ç†è·¯ç”±å†å²è®°å½•ï¼Œç”¨äºå¯ç›‘æ§å¼è·¯ç”±è·¯å¾„
 * @return {*}
 */
export interface IHistoryManager {
  push(entry: NavigationInstruction): void;
  replace(entry: NavigationInstruction): void;
  back(): void;
  forward(): void;
  getAllHistory(): NavigationInstruction[];
  clear(): void;
}

/**
 * @description: è·¯ç”±æ•°æ®ï¼Œç”¨äºå­˜å‚¨å…¨éƒ¨è·¯ç”±ä¿¡æ¯
 * @return {*}
 */
export interface IRoute {
  routes: ResolvedRoute[];
  routeMap: Map<string, ResolvedRoute>;
  createRouteMap(): void;
  addRoute(route: ResolvedRoute): void;
}

```
:::

::: code-group-item pipeline
```ts
import { IHistoryManager, IMiddleware } from "./router_core";
import { NavigationContext } from "./router_domain";

/**
 * @description: ç®¡é“è®¾è®¡ï¼Œå½“å‰è¿™ä¸ªæ˜¯é˜»å¡å¼çš„ç®¡é“è®¾è®¡ï¼Œä¾æ¬¡å¤„ç†ä¸­é—´ä»¶
 * @return {*}
 */
export class NavigationPipeline {
  middlewares: IMiddleware[] = [];
  errorHandler?: (error: Error, context: NavigationContext) => void;

  async pipe(context: NavigationContext): Promise<void> {
    let index = 0;
    const next = async () => {
      if (index < this.middlewares.length) {
        const middleware = this.middlewares[index++];
        await middleware.process(context, next);
      }
    };
    await next();
  }
  addMiddleware(middleware: IMiddleware): void {
    this.middlewares.push(middleware);
  }
  onError(handler: (error: Error, context: NavigationContext) => void): void {
    this.errorHandler = handler;
  }
}

/**
 * @description: è·¯ç”±å®ˆå«ä¸­é—´ä»¶
 * @return {*}
 */
export class GuardMiddleware implements IMiddleware {
  async process(
    context: NavigationContext,
    next: () => Promise<void>
  ): Promise<void> {
    const route = context.currentRoute;
    for (const guard of route.guards) {
      const result = await guard(context);
      //   è‹¥å¾—åˆ°äº†æ–°çš„è·³è½¬è·¯å¾„ï¼Œåˆ™è·³è½¬åˆ°æ–°çš„è·¯å¾„
      if (result) {
        context.instruction = result;
        break;
      }
    }
    await next();
  }
}

export class HistoryMiddleware implements IMiddleware {
  histroyManager: IHistoryManager;
  constructor(histroyManager: IHistoryManager) {
    this.histroyManager = histroyManager;
  }
  async process(
    context: NavigationContext,
    next: () => Promise<void>
  ): Promise<void> {
    const instruction = context.instruction;
    const type = instruction.type;
    this.histroyManager[type](instruction);
    next();
  }
}

```
:::
::: code-group-item Adapter
```ts

import { INavigator, IRouteResolver, IHistoryManager, IRoute } from "./router_core"
import { NavigationPipeline } from "./router_pipeline"

export abstract class AbstractRouterAdapter {
    navigator: INavigator
    resolver: IRouteResolver
    history: IHistoryManager
    route:IRoute
    pipeline: NavigationPipeline
    initialize(route:IRoute,pipeline:NavigationPipeline): void{
        this.route = route
        this.pipeline = pipeline
        this.navigator = this.createNavigator()
        this.resolver = this.createResolver()
        this.history = this.createHistory()
    }
    abstract createNavigator(): INavigator
    abstract createResolver(): IRouteResolver
    abstract createHistory(): IHistoryManager
    abstract errorHandler():void
}

```
:::
::::

## è¿™é‡Œé¢éƒ½æœ‰ä»€ä¹ˆï¼Ÿ
### æ ¸å¿ƒæ¨¡å—
1. å¯¼èˆªå™¨ï¼ˆINavigatorï¼‰
å¯¼èˆªå™¨æ˜¯è¿™ä¸ªè®¾è®¡çš„å¯¼èˆªå£ï¼Œé€šè¿‡è¿™ä¸ªå»è°ƒç”¨è·³è½¬ï¼Œè¿™å¹¶æ²¡æœ‰ç ´åæˆ‘ä»¬ä½¿ç”¨vue-routeræˆ–è€…react-routerçš„ä¹ æƒ¯ï¼Œè€Œåœ¨å®ç°æ—¶ï¼Œä½ éœ€è¦åœ¨è¿™é‡Œï¼Œå®ç°æ‰§è¡Œä¸Šä¸€é¡µçš„routerLeaveçš„äº‹ä»¶ã€ä¸­é—´ä»¶å¤„ç†ç„¶åå°±å¾—åˆ°äº†ä½ çœŸæ­£å¥—è¦è·³è½¬çš„è·¯å¾„çš„ç›¸å…³æ•°æ®ï¼Œè·³è½¬å‰éœ€è¦æ‰§è¡Œè·³è½¬å‰çš„é’©å­å‡½æ•°ã€‚

æˆ‘å¹¶æ²¡æœ‰ç›´æ¥åœ¨è®¾è®¡ä¸­ä½“ç°è¿™ä¸ªé¡ºåºçš„é€»è¾‘ï¼Œå› ä¸ºæ¯ä¸€å—éƒ½åº”è¯¥å¯ä»¥å»æè‡ªå·±çš„æµç¨‹ï¼Œå®Œå…¨å¯ä»¥åˆ å‡ä¸€äº›æˆ‘è¿™é‡Œçš„è®¾è®¡ã€‚

2. è·¯ç”±è§£æå™¨ï¼ˆIRouteResolverï¼‰
è·¯ç”±è§£æå™¨ä»è·¯ç”±ä¿¡æ¯ä¸­è§£æå‡ºæ¥æˆ‘åŸå§‹çš„è·¯ç”±é…ç½®å¯¹è±¡ã€‚å¯¹äºé¡µé¢çš„å¯¼èˆªé…ç½®ç›¸å…³ç»†åˆ™ï¼Œå°±åœ¨è¿™é‡Œé¢äº†ã€‚

3. ä¸­é—´ä»¶ä¸å¯¼èˆªç®¡é“ï¼ˆNavigationPipelineï¼‰
æˆ‘å€Ÿé‰´äº†ç®¡é“æ¨¡å¼ï¼Œä¸”æ˜¯é˜»å¡å¼çš„ç®¡é“æ¨¡å¼ã€‚åœ¨å¯¼èˆªå‰ï¼Œç”¨ä¸­é—´ä»¶å»å¤„ç†æ¯ä¸ªè·¯ç”±éœ€è¦å¤„ç†çš„äº‹æƒ…ï¼Œæ¯ä¸ªä¸­é—´ä»¶åªè´Ÿè´£ä¸€ä»¶äº‹ï¼Œæ¯”å¦‚è·¯ç”±å®ˆå«æ£€æŸ¥æƒé™ã€å†å²ç®¡ç†è®°å½•è·¯å¾„ç­‰ã€‚è¿™æ ·çš„æ¨¡å—åŒ–è®¾è®¡å¯ä»¥éšæ—¶æ’æ‹”ä¸åŒé€»è¾‘å¤„ç†ï¼Œæƒ³åŠ ä¸ªæ–°éœ€æ±‚ï¼Ÿæ’ä¸ªä¸­é—´ä»¶å°±æå®šï¼Œç»´æŠ¤èµ·æ¥ä¹Ÿé¡ºæ‰‹ã€‚

4. å†å²ç®¡ç†å™¨ï¼ˆIHistoryManagerï¼‰
ä¸»åŠ¨å¯¹å†å²è®°å½•è¿›è¡Œç®¡ç†å’Œè¿½è¸ªï¼Œå¯æ§çš„æ–¹å¼å»è¿›è¡Œå†å²ç®¡ç†ã€‚è¿™é‡Œæ¨èç”¨ History APIå»å®ç°ï¼Œè¾¾åˆ°å’Œæµè§ˆå™¨åŒæ­¥å†å²è®°å½•æ ˆã€‚
5. é€‚é…å™¨ï¼ˆAbstractRouterAdapterï¼‰
é€‚é…å™¨ï¼Œå°±æ˜¯ç”¨ä¸åŒæ¡†æ¶æ¥å¯¹æ¥çš„æ¥å£ã€‚æˆ‘å®šä¹‰äº†ä¸€ä¸ªæŠ½è±¡ç±» AbstractRouterAdapterï¼Œé‡Œé¢å°è£…äº†é€šç”¨çš„æ¥å£å’Œæ–¹æ³•ã€‚åªè¦ä¸ºç‰¹å®šæ¡†æ¶å®ç°ä¸€ä¸ªé€‚é…å™¨ï¼Œæˆ‘çš„æ•´ä¸ªè·¯ç”±ç³»ç»Ÿå°±èƒ½æ— ç¼æ¥å…¥ï¼Œæ— è®ºæ˜¯ Reactã€Vue è¿˜æ˜¯ Angularï¼Œä½ å¯ä»¥ä¸å¿…å†é‡å†™è·¯ç”±çš„å„ç§é€»è¾‘ï¼Œç›´æ¥å¤ç”¨

### æ¶‰åŠçš„è®¾è®¡æ¨¡å¼
- é€‚é…å™¨æ¨¡å¼å’Œå·¥å‚æ¨¡å¼è®©æˆ‘å®ç°äº†è·¨æ¡†æ¶å¤ç”¨å’Œå®ä¾‹åˆ›å»ºçš„çµæ´»æ€§ã€‚
- ç®¡é“æ¨¡å¼å’Œè§‚å¯Ÿè€…æ¨¡å¼å¢å¼ºäº†å¯¼èˆªè¿‡ç¨‹çš„æ¨¡å—åŒ–å’Œå¯æ§æ€§ã€‚
- ç­–ç•¥æ¨¡å¼åˆ™è®©å¯¼èˆªè¡Œä¸ºæ›´åŠ åŠ¨æ€å’Œå¤šæ ·åŒ–ã€‚

å¯¹äºè®¾è®¡æ¨¡å¼ï¼Œå–„ç”¨å¯ä»¥å¢åŠ å¯è¯»æ€§å’Œå¯æ‰©å±•æ€§ï¼Œå¦åˆ™å°±æ˜¯ç ´åä»£ç ç®€å•æ€§ã€‚

## umlå›¾
ä»¥ä¸‹umlå›¾ï¼Œå¯ä»¥å¸®ä½ å¿«é€Ÿçš„ç†è§£æˆ‘è¿™é‡Œçš„ä¾èµ–å…³ç³»ï¼Œä»–æ˜¯å•å‘çš„ï¼Œé«˜å±‚ç­–ç•¥å’Œä½å±‚ç­–ç•¥æ˜¯å¾ˆæ˜æ˜¾çš„ã€‚
```uml
@startuml é«˜çº§è·¯ç”±æŠ½è±¡è®¾è®¡

' é¢†åŸŸæ¨¡å‹
package "Domain Models" {

    interface "NavigationOptions" {
        params?: Map<string, string> :è·¯ç”±å‚æ•°,æ¯”å¦‚ /user/:id
        query?: Map<string, string>  :æŸ¥è¯¢å‚æ•°,æ¯”å¦‚ ?id=1
        hash?: string :æ¯”å¦‚é”šç‚¹
    }
    enum "NavigationType" {
        push
        replace
        back
        forward
    }

    interface RouteGuard {
        (context: NavigationContext): NavigationInstruction| void | Promise<NavigationInstruction|void>;
    }

    interface RouterBefore {
        (context: NavigationContext): void | Promise<void>;
    }
    interface RouterLeave {
        (context: NavigationContext): void | Promise<void>;
    }


    class "NavigationContext" {
        +instruction: NavigationInstruction :å¯¼èˆªæŒ‡ä»¤
        +prevInstruction: NavigationInstruction
        +nextInstruction: NavigationInstruction
        +currentRoute: ResolvedRoute
    }

    class "NavigationInstruction" {
        +type: NavigationType
        +target: string
        +options: NavigationOptions
        +timestamp: number
    }

    class "ResolvedRoute" {
        +path: string
        +name?: string
        +component: any
        +guards: RouteGuard[] :è·¯ç”±å®ˆå«,ç”¨äºæ‹¦æˆªå¯¼èˆª
        +enterHook: RouterBefore[] :å®Œæˆä¸€äº›é¢„å¤„ç†ä»»åŠ¡
        +leaveHook: RouterLeave[] :å®Œæˆä¸€äº›åå¤„ç†ä»»åŠ¡
        +children: ResolvedRoute[] :å­è·¯ç”±
        +metadata: Map<string, any>
    }
}

' æ ¸å¿ƒé€»è¾‘æŠ½è±¡
package "Core Abstractions" {

    ' å¯¼èˆªå™¨ï¼Œä½¿ç”¨æœ‰ä¸¤ç§æ–¹å¼è¿›è¡Œç¼–ç¨‹å¼è·¯ç”±å¯¼èˆª
    interface "INavigator" {
        +to(type: NavigationType, target: string, options: NavigationOptions): Promise<void> :é€šè¿‡å­—ç¬¦ä¸²ç±»å‹è¿›è¡Œè·¯ç”±å¯¼èˆªçš„æ–¹å¼
        +push(target: string, options: NavigationOptions): Promise<void>
        +replace(target: string, options: NavigationOptions): Promise<void>
        +back(): Promise<void>
        +forward(): Promise<void>
    }
    ' è·¯ç”±è§£æå™¨ï¼Œç”¨äºè§£æè·¯ç”±è·¯å¾„
    interface "IRouteResolver" {
        +resolve(path: string): Promise<ResolvedRoute>
    }

    interface "IMiddleware" {
        ' æ‰§è¡Œæ­¤ä¸­é—´ä»¶é€»è¾‘
        +process(context: NavigationContext, next: () => Promise<void>): Promise<void>
    }

    interface "IHistoryManager" {
        +push(entry: NavigationInstruction): void
        +replace(entry: NavigationInstruction): void
        +back(): void
        +forward(): void
        +getAllHistory(): NavigationInstruction[]
        +clear(): void
    }

    interface "IRoute" {
        routes: ResolvedRoute[]
        routeMap: Map<string, ResolvedRoute>
        +createRouteMap(): void: æ ¹æ®routesåˆ›å»ºè·¯ç”±æ˜ å°„è¡¨
        +addRoute(route: ResolvedRoute): void
    }
}



package "Pipeline" {
    class "NavigationPipeline" {
        -middlewares: IMiddleware[]
        -errorHandler?: (error: Error, context: NavigationContext) => void
        +pipe(context: NavigationContext): Promise<void>
        +addMiddleware(middleware: IMiddleware): void
        +onError(handler: (error: Error, context: NavigationContext) => void): void
    }
    ' è·¯ç”±å®ˆå«ä¸­é—´ä»¶
    class "GuardMiddleware" {
        +process(context: NavigationContext, next: () => Promise<void>): Promise<void>
    }
    '
    class "HistoryMiddleware" {
        +process(context: NavigationContext, next: () => Promise<void>): Promise<void>
    }
}


package "Framework Adapters" {
    abstract class "AbstractRouterAdapter" {
        +navigator: INavigator
        #resolver: IRouteResolver
        +history: IHistoryManager
        +route:IRoute
        #pipeline: NavigationPipeline
        +initialize(route:IRoute,pipeline:NavigationPipeline): void
        +{abstract} createNavigator(): INavigator
        +{abstract} createResolver(): IRouteResolver
        +{abstract} createHistory(): IHistoryManager
        +{abstract} errorHandler():void
    }
}

' å…³ç³»å®šä¹‰


NavigationPipeline o-- IMiddleware
AbstractRouterAdapter o-- INavigator
AbstractRouterAdapter o-- IRouteResolver
AbstractRouterAdapter o-- NavigationPipeline
AbstractRouterAdapter o-- IHistoryManager

GuardMiddleware ..|> IMiddleware
HistoryMiddleware ..|> IMiddleware

NavigationContext --* NavigationInstruction
NavigationContext --* ResolvedRoute
ResolvedRoute o-- RouteGuard
ResolvedRoute o-- RouterBefore
ResolvedRoute o-- RouterLeave
ResolvedRoute o-- ResolvedRoute
NavigationInstruction --> NavigationType
NavigationPipeline --> NavigationContext

IRouteResolver --> ResolvedRoute
INavigator --> NavigationType
INavigator --> NavigationOptions
IHistoryManager o-- NavigationInstruction
IRoute o-- ResolvedRoute

note right of NavigationPipeline
    å¯¼èˆªç®¡é“
    å¤„ç†æ‰€æœ‰å¯¼èˆªç›¸å…³çš„ä¸­é—´ä»¶
end note

note right of IMiddleware
    ä¸­é—´ä»¶æ¥å£
    å®šä¹‰äº†å¯¼èˆªè¿‡ç¨‹ä¸­çš„å¤„ç†å•å…ƒ
end note

note right of AbstractRouterAdapter
    è·¯ç”±é€‚é…å™¨æŠ½è±¡åŸºç±»
    å¯ä»¥é‡‡ç”¨é€‚é…å™¨æ¨¡å¼æ¥å®ç°ä¸åŒæ¡†æ¶çš„è·¯ç”±é€‚é…
    ä¹Ÿå¯ä»¥é‡‡ç”¨å·¥å‚æ¨¡å¼æ¥åˆ›å»ºä¸åŒæ¡†æ¶çš„è·¯ç”±é€‚é…å™¨
end note

@enduml

```
**ä½ å¯ä»¥å³é”®ä¸‹é¢è¿™ä¸ªå›¾ï¼Œåœ¨æ–°çš„æ ‡ç­¾é¡µä¸­æ‰“å¼€ï¼Œè¿™æ ·å¯ä»¥æ”¾å¤§å’Œæ‹–åŠ¨çš„æŸ¥çœ‹**
@startuml é«˜çº§è·¯ç”±æŠ½è±¡è®¾è®¡
@startuml é«˜çº§è·¯ç”±æŠ½è±¡è®¾è®¡

' é¢†åŸŸæ¨¡å‹
package "Domain Models" {

    interface "NavigationOptions" {
        params?: Map<string, string> :è·¯ç”±å‚æ•°,æ¯”å¦‚ /user/:id
        query?: Map<string, string>  :æŸ¥è¯¢å‚æ•°,æ¯”å¦‚ ?id=1
        hash?: string :æ¯”å¦‚é”šç‚¹
    }
    enum "NavigationType" {
        push
        replace
        back
        forward
    }

    interface RouteGuard {
        (context: NavigationContext): NavigationInstruction| void | Promise<NavigationInstruction|void>;
    }

    interface RouterBefore {
        (context: NavigationContext): void | Promise<void>;
    }
    interface RouterLeave {
        (context: NavigationContext): void | Promise<void>;
    }


    class "NavigationContext" {
        +instruction: NavigationInstruction :å¯¼èˆªæŒ‡ä»¤
        +prevInstruction: NavigationInstruction
        +nextInstruction: NavigationInstruction
        +currentRoute: ResolvedRoute
    }

    class "NavigationInstruction" {
        +type: NavigationType
        +target: string
        +options: NavigationOptions
        +timestamp: number
    }

    class "ResolvedRoute" {
        +path: string
        +name?: string
        +component: any
        +guards: RouteGuard[] :è·¯ç”±å®ˆå«,ç”¨äºæ‹¦æˆªå¯¼èˆª
        +enterHook: RouterBefore[] :å®Œæˆä¸€äº›é¢„å¤„ç†ä»»åŠ¡
        +leaveHook: RouterLeave[] :å®Œæˆä¸€äº›åå¤„ç†ä»»åŠ¡
        +children: ResolvedRoute[] :å­è·¯ç”±
        +metadata: Map<string, any>
    }
}

' æ ¸å¿ƒé€»è¾‘æŠ½è±¡
package "Core Abstractions" {

    ' å¯¼èˆªå™¨ï¼Œä½¿ç”¨æœ‰ä¸¤ç§æ–¹å¼è¿›è¡Œç¼–ç¨‹å¼è·¯ç”±å¯¼èˆª
    interface "INavigator" {
        +to(type: NavigationType, target: string, options: NavigationOptions): Promise<void> :é€šè¿‡å­—ç¬¦ä¸²ç±»å‹è¿›è¡Œè·¯ç”±å¯¼èˆªçš„æ–¹å¼
        +push(target: string, options: NavigationOptions): Promise<void>
        +replace(target: string, options: NavigationOptions): Promise<void>
        +back(): Promise<void>
        +forward(): Promise<void>
    }
    ' è·¯ç”±è§£æå™¨ï¼Œç”¨äºè§£æè·¯ç”±è·¯å¾„
    interface "IRouteResolver" {
        +resolve(path: string): Promise<ResolvedRoute>
    }

    interface "IMiddleware" {
        ' æ‰§è¡Œæ­¤ä¸­é—´ä»¶é€»è¾‘
        +process(context: NavigationContext, next: () => Promise<void>): Promise<void>
    }

    interface "IHistoryManager" {
        +push(entry: NavigationInstruction): void
        +replace(entry: NavigationInstruction): void
        +back(): void
        +forward(): void
        +getAllHistory(): NavigationInstruction[]
        +clear(): void
    }

    interface "IRoute" {
        routes: ResolvedRoute[]
        routeMap: Map<string, ResolvedRoute>
        +createRouteMap(): void: æ ¹æ®routesåˆ›å»ºè·¯ç”±æ˜ å°„è¡¨
        +addRoute(route: ResolvedRoute): void
    }
}



package "Pipeline" {
    class "NavigationPipeline" {
        -middlewares: IMiddleware[]
        -errorHandler?: (error: Error, context: NavigationContext) => void
        +pipe(context: NavigationContext): Promise<void>
        +addMiddleware(middleware: IMiddleware): void
        +onError(handler: (error: Error, context: NavigationContext) => void): void
    }
    ' è·¯ç”±å®ˆå«ä¸­é—´ä»¶
    class "GuardMiddleware" {
        +process(context: NavigationContext, next: () => Promise<void>): Promise<void>
    }
    '
    class "HistoryMiddleware" {
        +process(context: NavigationContext, next: () => Promise<void>): Promise<void>
    }
}


package "Framework Adapters" {
    abstract class "AbstractRouterAdapter" {
        +navigator: INavigator
        #resolver: IRouteResolver
        +history: IHistoryManager
        +route:IRoute
        #pipeline: NavigationPipeline
        +initialize(route:IRoute,pipeline:NavigationPipeline): void
        +{abstract} createNavigator(): INavigator
        +{abstract} createResolver(): IRouteResolver
        +{abstract} createHistory(): IHistoryManager
        +{abstract} errorHandler():void
    }
}

' å…³ç³»å®šä¹‰


NavigationPipeline o-- IMiddleware
AbstractRouterAdapter o-- INavigator
AbstractRouterAdapter o-- IRouteResolver
AbstractRouterAdapter o-- NavigationPipeline
AbstractRouterAdapter o-- IHistoryManager

GuardMiddleware ..|> IMiddleware
HistoryMiddleware ..|> IMiddleware

NavigationContext --* NavigationInstruction
NavigationContext --* ResolvedRoute
ResolvedRoute o-- RouteGuard
ResolvedRoute o-- RouterBefore
ResolvedRoute o-- RouterLeave
ResolvedRoute o-- ResolvedRoute
NavigationInstruction --> NavigationType
NavigationPipeline --> NavigationContext

IRouteResolver --> ResolvedRoute
INavigator --> NavigationType
INavigator --> NavigationOptions
IHistoryManager o-- NavigationInstruction
IRoute o-- ResolvedRoute

note right of NavigationPipeline
    å¯¼èˆªç®¡é“
    å¤„ç†æ‰€æœ‰å¯¼èˆªç›¸å…³çš„ä¸­é—´ä»¶
end note

note right of IMiddleware
    ä¸­é—´ä»¶æ¥å£
    å®šä¹‰äº†å¯¼èˆªè¿‡ç¨‹ä¸­çš„å¤„ç†å•å…ƒ
end note

note right of AbstractRouterAdapter
    è·¯ç”±é€‚é…å™¨æŠ½è±¡åŸºç±»
    å¯ä»¥é‡‡ç”¨é€‚é…å™¨æ¨¡å¼æ¥å®ç°ä¸åŒæ¡†æ¶çš„è·¯ç”±é€‚é…
    ä¹Ÿå¯ä»¥é‡‡ç”¨å·¥å‚æ¨¡å¼æ¥åˆ›å»ºä¸åŒæ¡†æ¶çš„è·¯ç”±é€‚é…å™¨
end note

@enduml


